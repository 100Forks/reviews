>> Can you give some use cases when to use and when not to use operator overloading? >> Operator overloading is a very powerful mechanism, but with a lot of power, comes a lot responsibility and this is why Kotlin only provides a very restricted version of operator overloading. For example, you cannot invent your own new operator or alter precedence of existing operators. All you're allowed to do is overload a predefined set of operators. These are mostly related to arithmetic, indexation, comparisons, so on so forth. So, it can be very tempting to abuse this, and make up your own syntax so to speak, like for example, one can think of a 'Path' class that uses slash operator for concatenation, making like Linux like slash separated path objects. But, I would say that this is already an abuse of the language mechanism. So, you're supposed to use slash for division, and plus for sums or concatenation, so on and so forth. So, my advice would be to only use operator overloading on the abstractions that have natural, commonly acknowledged operations signified by the symbols that we have in the language. So, use it with care and it will provide for readable intuitive code. >> Why does Kotlin rely on naming conventions and not interfaces? >> Customizable language constructs are very useful. Iteration is an archetypical example of this where you have a 'for' loop that's customizable through user provided iterator, for example. There, Kotlin relies on naming conventions and not interfaces like Java does. There are reasons to it and one is that such an iterator method or any other convention provided operator can be supplied through an extension, which makes it possible to add these things to classes not under our control. For example, classes, settings and libraries, or JDK, or something in a different module, something that I cannot simply add a method to, at least easily. So that's one important reason and the other is, it again provides a way of decoupling the additional operations, utility things, from the essence of the abstraction. So, if iteration, for example, is not an intrinsic part of your class and just a convenience, you can put it into an extension and separate from the clean interface you keep with your members. So, two ideas: minimal abstractions and extending existing code, basically the same as we have for keeping extensions in the language.