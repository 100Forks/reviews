In this video, you will learn the different syntax of how to define a function in Kotlin. Also, we'll touch the question of Java interoperability and discuss how to call a top-level function from Java. Here you can see the syntax for function in Kotlin. This function returns a maximum of two values. Note that the parameter type specification is put after the parameter name like for variables. In a similar manner, function return type specification follows the argument list. If your function simply returns one expression, you can use an alternative syntax, so-called, "function with expression body". IDE like IntelliJ Idea or Android Studio can automatically convert from one form to another. The expression that the function returns goes after the ‘equals’ sign. IntelliJ IDEA nicely highlights the type specification for us, and by pressing only one key you can either remove it or leave it. It makes sense to specify types explicitly for public API, for library functions. If it's a regular application, you have a function, especially a private one, and its type is clear, for instance, from its name, you can safely omit it. Note that if you try to omit the type for a function with expression body, it will mean that this function returns 'Unit'. You can think of 'Unit' as an analogue of 'void'. The ‘dispayMax’ function returns no meaningful value, it’s written for its side effects, and the compiler considers its type as ‘Unit’. You can use an alternative syntactic form by specifying 'Unit' explicitly, but I think no one does that. In Kotlin you can define functions everywhere. You saw that you can define a function at the top level, or make it a member of a class. You can even define a function inside another function, then it's called a local function. Sometimes it's really convenient. What do you think: Is it possible to call a top-level function from Java? If that’s possible, then how to access it from Java? And there are options: you can't do it, or you can call it as a static or member function of the class which name corresponds to the file name containing this function. From Java, you call a top-level function as a static function. All top-level functions under the hood are implemented as static functions. Here is the example. We define a top-level function 'foo' in Kotlin, and from Java you can call it as a static function. The top-level function is defined in the file called ‘MyFile.kt’. At the bytecode, the underlying static function belongs to a class ‘MyFileKt’. From Java, you can import a class by its name, or use 'import static'. This last syntax gives you the same 'foo()' invocation as in Kotlin. If you want you can change the name of the class that contains all the top-level functions as 'static' functions. For that, you use a '@JVMName' annotation. You annotate the file contents and put the annotation right before the package name. Now you call 'foo()' as a member of a class which name you specified: in this example, of the class 'Util’. Now you know the difference between “function with a block body" in Kotlin and "function with expression body". You've also learned about '@JVMName' annotation that can change the name of the class containing top-level functions. Next, we'll see how Kotlin can improve a function invocation.