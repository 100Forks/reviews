In this section, we'll
discuss Kotlin types, several Java types
they correspond to, and discuss what happens with these types under the hood
at the bytecode level. In Kotlin, we don't distinguish primitive
types and reference types. You either use Int
or nullable Int. There are no primitives
in the language. However, let's
discuss what happens under the hood at
the bytecode level. You can call show Kotlin bytecode action in IntelliJ idea or Android Studio. It opens you the
generated bytecode corresponding to
the open Kotlin file. In the bytecode, you can
check the return type for functions whether it
returns a primitive file, or your oil wrapper type. However, there is
an easier option. You see here
the decompile button. This button will decompile the generated bytecode to
the analogous Java code. If you click on it, you'll see the Java code that corresponds to the initial Kotlin code. That's a good illustration of how the Kotlin functions and classes are implemented
under the hood. At the same time, it shows how Java sees
Kotlin functions and classes because Java just accesses the Kotlin code
via generated bytecode. As you can see, when you use a regular Int type in Kotlin, it corresponds to a primitive
Int type under the hood. When you use nullable Int, this value can straw nulls. So, it should correspond
to a wrapper type in Java. We don't have primitive
types in the language, but we still have them
at the bytecode level. The same applies to other primitives like
double float or Boolean. Note however that if you use
Int as a generic argument, then it can't be
compiled to a primitive because you cannot use
primitives as generic arguments. It becomes a reference type. The same works for arrays. When you use Int as
a generic argument of array, that corresponds to an array
of [inaudible] types. To get an array of primitive
types under the hood, you need to use an extra class like Int array or double array. Kotlin string is replaced with Java lang string
at the bytecode. Kotlin doesn't have
its own string implementation. However, it modifies
the bit of the string API. For instance, Kotlin string has some confusing methods that are present in Java lang string. In Java, you can use
the replace all method. Surprisingly, it will
return your all stars so when you try to replace
only a dot with this star. That happens because dot here
is a regular expression. In Kotlin, we have
two separate methods. The first one replaces dot with stars and works as you expect. It simply replaces sub-strings. If you want regular expressions, you pass a specific regular
expression type not a string. Now you're not surprised
seeing the result. Any is replaced with Java lang object added
to the bytecode. Any in Kotlin is a super type
for all non-nullable types. Unlike object, any is not only super type
for reference types, but it's also
super type for types like Int corresponding
to primitives. Note that under the hood, the autoboxing still
happens like in Java. When you pass an integer as an argument to a function
that expects any, this integer will be autoboxed
to a reference type. The same happens in
Java when you pass a primitive as
an instance of object. If you want to avoid it, you declare a function
that takes Int. Now, it corresponds to a function that takes
a primitive int and the primitive value
can be just passed to it. No boxing happens in this case. Add to the bytecode unless
lambdas are in lined, the Kotlin function types
are replaced with regular interfaces
like function zero, function one and function two with the corresponding
generic arguments. You can find the declaration of this function interfaces
in the library. In the Kotlin code, you use the concise
syntactic forms for function types which are replaced by the corresponding
interfaces under the hood. When the lambda is not in lined, an instance of the corresponding function interface is passed. If the lambda is in lined, then [inaudible] is created all the
code is generated directly. When you call a variable
of a function type as a function using the parentheses
in the bytecode, this call is replaced with
a direct invoke call. Unless this code is
in light of course. As we've already discussed, you can call invoke
explicitly from Kotlin. For expressions of
function types, is the same as using
the concise syntax. The case when it's really
helpful is working with variables of
nullable function types. The next question returns us
to the discussion of arrays. What will be printed
here? True or false? Under the hood, Kotlin arrays
are regular Java arrays. Specifically, they don't override the equals
implementation. Equals for Kotlin arrays works in the same way as
for Java arrays. The right answer is false. I have told you
that Kotlin arrays simply corresponds
to Java arrays. In Java, you have to be
aware that by default, equals checks reference
equality for arrays. If you need to check the contents instead of reference equality, can use arrays equals. In Kotlin, it works
in a similar manner. Double equals sign which calls equals in
Kotlin only checks reference equality
since equals method for arrays works that way. In Kotlin, you use the extension content equals to
compare the contents. The good news is that in
Kotlin you rarely use arrays. Kotlin has arrays specifically to have good Java
interoperability to make it easier to work with
Java API that uses arrays. If you write the Kotlin
application from scratch and use only Kotlin, there is no reason for arrays. You can simply use lists. As we'll discuss later, mutable list is Java util
array list under the hood. Array list is very close to array in terms of performance. So, prefer lists to
arrays by default and avoid the necessity to remember the right way to compare arrays. You now know that
despite Kotlin doesn't distinguish between
primitive and reference types, they're still hidden
under the hood. The boxing happens
whenever you interpret a primitive value as
a value of reference type. Next, we'll uncover the
difference between nothing and unit types and compare
them with Javas void.