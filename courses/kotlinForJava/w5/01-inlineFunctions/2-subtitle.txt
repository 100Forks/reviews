In this video, we'll slowly
unwrap how inlining works, and how it's different
from non-line case. Let's imagine we define
our line function as a regular function without the inline modifier.
What happens then? When do we call a
function that takes a lambdas in argument under the hood to store the lambda an anonymous
class is created. If the lambda captures
some variables, then a new object will
be created to store the contents of captured
variables for each invocation. That's quite an overhead for such a simple case in
terms of performance. In comparison with simply writing the code without run
function with lambda, that would be
a considerable difference. If we defined the run
function like this, then probably there would
be style guides that would recommend don't use run any performance critical
part of the code. Use it with care.
Be aware that under the hood there is an anonymous class
corresponding to this lambda. It wouldn't be zero overhead
to use run it in your code. Within lining it's
no longer the case. Inlining of function
means that the compiler substitutes the body of this faction instead
of calling it. If the inline function
takes lambda as an argument and only
calls this lambda in set, then inlining will
substitute the body of it. Lambda instead of the code
that calls this lambda. Run is the simplest example. It only calls the lambda
and does nothing else. At the bytecode level while generating the code
for their own code, the compiler instead of calling run and creating an object
called the lambda, will generate
the lambda body directly. As a result, we have
no performance over head or creating an anonymous class
and an object for the lambda. Again, indicates that
without in line we have the performance overhead
in comparison to writing the similar
code without run. When you make it in
line it stays the same. The generated bytecode doesn't differ from the code without run. That was a trival examples. Run similar calls the lambda. Now let's look at the take and less function that does
something less trivial. It contains some logic
with if expression. Instead of calling the take and less last function
in the bytecode, the compiler in lines it
and substitute its body. Instead of the lambda invocation, it substitutes the code
of the lambda body. You can see here that instead of creating an object for lambda, we have the lambda code written directly in
the resulting bytecode. Of course, the compiler
imposes some constraints of what can be done with lambdas
inside inline functions. You can't draw the lambda anyway, you can only call it directly. Then it's possible to generate
the lambda code in place. All measured library
functions simply called a lambda by
zeros several times, but don't try to
postpone the call. Let's look at another example. Java has this synchronized
language construct. In Kotlin, a similar construct can be defined as a
function in the library. When the synchronized function
is marked as inline, that means it produces
no performance overhead. In the resulting bytecode, and the whole function body is substituted instead of one call. The compiler
generates the body of the synchronized
function replacing the parameters usages with
actual arguments passed. Whenever the compiler finds
the lambda invocation, it generates
the lambda body instead. Note that whenever you need to do something with logs instead
of synchronized in kotlin, you can use with log. It does a similar thing but it is defined
as an extension. You call with lock
on the lock object. Yet another function to illustrate the pattern
that in Kotlin some functions look like built-in language constructs and replace built-in
language constructs, but in fact declarative
functions in the library. In Java, we have
try-with-resources syntax. The tri expression
can close your source in the correct manner if
an exception was thrown. It correctly propagates
the initial exception if another exception is thrown when you
close the resource. In Java is a special construct
in the language. In Kotlin, all this logic is defined inside the
regular library function. This library function
is defined as inline. So there is no performance
overhead because of lambdas. The use function contains all the aforementioned logic of closing the resources
in the correct way. There is no performance
over head when he used the library functions
like run overhead. No anonymous classes or extra objects are created
for lambda's under the hood. It's free to use
this functions in your code. You can note that the filter function is also
defined as enlightened. We'll discuss in the next
section what consequences we have because of that for operations and working
with collections. But for now to better understand how it works, do this exercise. Write the code that will be generated for
the filter function. Before the exercise right after the video in
the coding playground. Write your solution
and then check the proposed solution
in a separate video. One more question before that, what do you think will
the filter function be in lined in the bytecode
if you call it prom Java? I've already told you that this filter function is defined
in the libraries inline. Yes or no? The answer
is of course no. Inlining is the feature
of the coding compiler. Whenever the compiler sees that the inline
function is called, it will generate the body
of the function instead of one call but Java doesn't know anything
about enlightening. From Java, you can easily
call the coding functions but the major coffin lightning happens only inside
the coding compiler, not inside the Java compiler. From Java, inline functions are called like regular functions. Nothing gets inlined. If you navigate to the sources of
the mentioned functions, you'll find out that
the majority of them are defined as inline only. That means these functions
are always in lined. If the library function is
always inlined in Kotlin, there is no sense to store it in the resulting jar file when
you build your application. So that decreases the size
of your application. Inline only annotation marks which functions can be removed
from the resulting term. That means you won't be able
to call them prompt Java. They are only accessible
and feasible from Kotlin. This notation is internal
and it tended to be used only in this standard
library at least so far. By covering this
internal innovation, I'm trying to explain
how that works and share the power of
the standard library. Note that the main
disadvantage of inlining is the size of
the resulting application. Because for each inlined
function when you call it, its whole body is substituted instead of
only one function call. That's only small functions
must be inlined. By default, don't define
your functions as inline. Hotspot when running the bytecode does a good job of optimizing and inlining pieces of code that are really
frequently used. So don't do the
premature optimization. We spent a lot of time
discussing inlining so you can better understand the language and it's
powerful library. However, don't reuse inlining. Use that with care. Now know about such library
functions as run, lead, or take, if, repeat or with log, and you can use
them in your code. You know that using them doesn't affect the farmers
because they are declared as inlined and no extra objects or classes are created when you pass
lambdas as arguments. Next, we'll discuss how inlining affects functional operations
on collections.