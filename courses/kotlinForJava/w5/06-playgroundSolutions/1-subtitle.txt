Our next task is to write the code that the compiler will generate instead of calling the 'filter' function because 'filter' is inlined. Here I provided one more implementation of the 'filter' function that we can use. The implementation in the standard library is kind of the same, but a bit different. So, we may use this one for simplicity. Now our task is: what code is generated instead of this line, instead of calling 'filter'. And we can simply copy paste the 'filter' function call. Then, replace all the values that are substituted to different values. At first, here we know that our 'T' is 'Int', we have a list of 'Int'. Then, 'this' reference. 'filter' is an extension function called on the receiver. In this case, our receiver is 'List'. Here we call 'filter' on 'list'. When we generate the code, 'list' is substituted instead of usages of 'this'. Then, we have this predicate and the main idea is that the lambda bodies are inlined. Instead of calling this predicate, creating this predicate and storing this lambda, its body is substituted directly. In this case, 'it' is replaced with 'element'. What we'll have in the end, is "element is not null". We check whether 'element' is not 'null' and if so we do what's expected. This task lets you practice to understand what code is generated by the compiler when you actually write a 'filter' function call. That was only for practice, all this code is generated at the bytecode level. You may try to see what the bytecode is generated by yourself. This task illustrates what's going on under the hood.